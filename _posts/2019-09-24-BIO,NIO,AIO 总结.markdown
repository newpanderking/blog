---
layout: post
title:  "BIO,NIO,AIO 总结"
date: 2019-09-24
categories: 技术
tags: java
description: BIO,NIO,AIO 总结
---

> Java 中的 BIO、NIO和 AIO 理解为是 Java 语言对操作系统的各种 IO 模型的封装。程序员在使用这些 API 的时候，不需要关心操作系统层面的知识，也不需要根据不同操作系统编写不同的代码。只需要使用Java的API就可以了。

在讲 BIO,NIO,AIO 之前先来回顾一下这样几个概念：同步与异步，阻塞与非阻塞。

#### 同步与异步
- **同步：**同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。
- **异步：**异步就是发起一个调用后，立刻得到被调用者的回应表示已经收到请求，但是被调用者并没有返回结果，此时我们可以处理其他请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。

> 同步和异步最大的区别在于异步调用的话调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果。

#### 阻塞和非阻塞
- **阻塞：**阻塞就是调用者发起一个调用后，调用者一直等待请求的返回结果，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。
- **非阻塞：**非阻塞就是发起一个请求，调用者者不用一直等待结果返回，可以先干其他事情。


### 1、BIO(Blocking I/O)
> 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。

#### 1.1 传统BIO
![]({{ "/assets/img4post/2019-09-24-BIO,NIO,AIO 总结-传统BIO.png" | absolute_url }})

> BIO通信，一请求一应答模型。采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接。我们一般通过在`while(true)`循环中服务端会调用`accept()`方法等待接收客户端的连接的方式监听请求，请求一但接收到一个连接请求,就可以建立通信套接字在这个通信套接字上读写操作，此时不能再接收其他客户端的连接请求，只能等待同当前连接的客户端的操作执行完成，不可以通过多线程多线程来支持多个客户端的连接。如果让BIO通信模型同时处理多个客户端请求，就必须使用多线程（主要原因`socket.accept()`、`socket.read()`、`socket.write()`涉及的三个主要函数都是同步阻塞的），也就是说它在接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成之后，通过输出流返回应答给客户端，线程销毁。这就是典型的**一请求一应答通信模型**。我们可以假设如果这个连接不做任何事情的话就会造成不必要的线程开销，不过可以通过线程池的机制优化，线程池还可以让线程的创建和收回成本相对较低。使用`FixedThreadPool`可以有效的控制线程的最大数量，保证了系统有限的资源控制，实现了`N（客户端请求数量）: M（处理客户端请求的线程数）`的伪异步I/O模型（N远大于M）。

> 在 Java 虚拟机中，线程是宝贵的资源，线程的创建和销毁成本很高，除此之外，线程的切换成本也是很高的。尤其在 Linux 这样的操作系统中，线程本质上就是一个进程，创建和销毁线程都是重量级的系统函数。如果并发访问量增加会导致线程数急剧膨胀可能会导致线程堆栈溢出、创建新线程失败等问题，最终导致进程宕机或者僵死，不能对外提供服务。


#### 1.2 伪异步IO
>为了解决同步阻塞I/O面临的一个链路需要一个线程处理的问题，后来有人对它的线程模型进行了优化一一一后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数M：线程池最大线程数N的比例关系，其中M可以远远大于N.通过线程池可以灵活地调配线程资源，设置线程的最大值，防止由于海量并发接入导致线程耗尽。

![]({{ "/assets/img4post/2019-09-24-BIO,NIO,AIO 总结-伪异步IO.png" | absolute_url }})

> 采用线程池和任务队列可以实现一种叫做伪异步的 I/O 通信框架，它的模型图如上图所示。当有新的客户端接入时，将客户端的 Socket 封装成一个Task（该任务实现java.lang.Runnable接口）投递到后端的线程池中进行处理，JDK 的线程池维护一个消息队列和 N 个活跃线程，对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。伪异步I/O通信框架采用了线程池实现，因此避免了为每个请求都创建一个独立线程造成的线程资源耗尽问题。不过因为它的底层仍然是同步阻塞的BIO模型，因此无法从根本上解决问题。
 

#### 1.3 总结
> 在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。 

### 2、NIO
#### 2.1 NIO简介
> NIO是一种同步非阻塞I/O模型，在Java1.4中引入了NIO框架，对应`java.nio`包，提供了Channel、Selector、Buffer等抽象。

> NIO中的N可以理解为Non-blocking。它支持面向缓冲的，基于通道的I/O操作方法。NIO提供了与传统BIO模型中的`Socket`和`ServerSocket`相对应的`SocketChannel`，`ServerSocketChannel`两种不同的套接字实现，两种通道都支持阻塞和非阻塞模式。阻塞模式支持的就像传统中支持的一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的网络应用，应该使用NIO的非阻塞模式开发。

#### 2.2 NIO的特性
- 2.2.1 Non-Blocking IO
 > **IO流是阻塞的，NIO流是非阻塞的**， Java-NIO使我们可以进行非阻塞IO操作。比如说，单线程中从管道读取数据到buffer, 同时可以继续做别的事情，当数据读取到buffe之后，线程在继续处理数据。写数据也是一样。另外，非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以做别的事情。Java-IO的各种流是阻塞的，这意味着当一个线程`read`或是`write`是，该线程被阻塞，或数据完全写入。该线程在此期间不能再干别的事情了。
 
- 2.2.2 Buffer缓冲区
 > **IO面向流，而NIO面向缓冲区**，Buffer是一个对象，它包含一些要写入或是要读出的数据。而NIO库中加入Buffer对象，体现了新库与原IO库的一个重要区别。面向流的IO中，可以将数据直接写入或将数据直接读到Stream对象中。虽然Stream中也有Buffer开头的扩展类，但只是流的包装类，还是从流读到缓冲区中，而NIO是直接读到Buffer中操作。最常用的Buffer区是ByteBuffer，一个ByteBuffer提供了一组功能用于操作byte数组。除了ByteBuffer,还有其他的一些缓冲区，事实上，每一种基本Java类型（除了Boolean类型）都对应有一个缓冲区。

- 2.2.3 Channel - 通道
 > NIO是通过Channel进行读写的，通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互，因为通道、Buffer可以异步的读写。

- 2.2.3 Selector - 选择器
 > NIO有选择器，而IO没有，选择器用于单个线程处理多个通道。因此它需要较少的线程来处理这些通道，线程之间的切换对于操作系统来说是昂贵的，因此为了提高效率，选择器是很有用的。
 
    ![]({{ "/assets/img4post/2019-09-24-BIO,NIO,AIO 总结-选择器.png" | absolute_url }})
 
#### 2.3 NIO读写数据的方式
> 通常来说NIO所有的IO都是从管道开始的。

 ![]({{ "/assets/img4post/2019-09-24-BIO,NIO,AIO 总结-NIO读写.png" | absolute_url }})
  
#### 2.4 NIO核心组件
- Channel - 管道
- Buffer - 缓冲区
- Selector - 选择器


#### 2.5 NIO拓展问题
> 为什么开发者不愿意使用JDK的原生NIO？

- JDK的原生NIO底层由epoll实现，该实现饱受诟病的空轮询bug会导致cpu飙升100%。
- 庞大的项目，自己实现NIO之后，很容易出现各种bug，维护成本高。
- Netty的出现很大程度上改善了JDK原生NIO所存在的一些让人难以忍受的问题。

### 3、AIO
> AIO也就是NIO-2，在Java7 中引入了NIO的改进版NIO-2，它是异步非阻塞的IO模型。异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会阻塞在那里，当后台处理完成之后，操作系统会通知相应的线程进行后续操作。AIO是异步IO的缩写，虽然NIO在网络操作中，提供了非阻塞的方法，但是NIO的IO行为还是同步行为。对于NIO，我们的业务线程是在IO操作准备好时，得到通知，接着就由这个线程自行进行IO操作，IO操作本身是同步的。
 
## 附录
- [漫话：如何给女朋友解释什么是Linux的五种IO模型？](https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&mid=2247484746&idx=1&sn=c0a7f9129d780786cabfcac0a8aa6bb7&source=41#wechat_redirect)
- 

 















  