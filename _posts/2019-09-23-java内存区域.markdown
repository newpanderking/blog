---
layout: post
title:  "Java 内存区域"
date: 2019-09-23
categories: 技术
tags: java
description: Java 内存区域
---

## 一、运行时数据区域
> JDK1.8和之前的版本略有不同

### JDK1.8之前
![]({{ "/assets/img4post/2019-09-23-java内存区域-JVM运行时数据区域内存图1.8之前.png" | absolute_url }})

### JDK1.8
![]({{ "/assets/img4post/2019-09-23-java内存区域-JVM运行时数据区域内存图1.8.png" | absolute_url }})

#### 线程私有
- 程序计数器
- 虚拟机栈
- 本地方法栈

#### 线程共享
- 堆
- 方法区
- 直接内存

### 程序计数器
> 程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。另外、为了线程切换后能够恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各个线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。
PS: 程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的消亡而消亡。

### 虚拟机栈
> 与程序计数器一样，Java虚拟机栈也是线程私有的，他的生命周期和线程相同，描述的是java方法执行的内存模型，每次方法调用的数据都是通过栈传递的。Java的内存可以粗糙的分为堆内存和栈内存，其中栈内存就是我们所指的虚拟机栈，或者说虚拟机栈中局部变量表部分。局部变量表主要存放了编译器可知的各种数据类型、对象引用。

- Java虚拟机栈会出现两种错误，`StackOverFlowError` 和 `OutOfMemoryError`。
	- `StackOverFlowError`: 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度时，就会抛出`StackOverFlowError`。
	- `OutOfMemoryError`: 若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈空间时，内存用完了，无法再动态扩展，此时就会抛出`OutOfMemoryError`。

### 本地方法栈
> 和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。
	
### 堆
> Java虚拟机中管理的内存最大的一块，Java堆是所有线程共享的一块内存区域，在虚拟机启动是创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都会在这里分配。

### 方法区
> 方法区和Java堆一样，是各个线程共享的内存区域，用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据。虽然Java虚拟机规范把Java虚拟机规范描述为堆的一个逻辑部分，但它却有一个别名叫做`None-Heap`,目的是与Java堆区分开。方法区也被称之为永久代。
 
- 方法区与永久代之间的关系
 > 方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。
 
- 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?
 > 整个永久代在JVM中本身设置了固定大小上下限，无法调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会得到`java.lang.OutOfMemoryError`。可以使用`-XX：MaxMetaspaceSize`标志设置最大元空间大小，默认为unlimited，这意味着它只受系统内存的限制。`-XX：MetaspaceSize`调整标志定义元空间的初始大小，如果该标记未指定，则MetaSpace将根据运行时应用程序需求动态重新调整大小。

### 运行时常量池
> 运行时常量池也是方法区的一部分。Class中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息。既然运行时常量池也是方法区的一部分，自然也受到方法区的内存限制，当常量池无法再申请到内存时，就会抛出`OutOfMemoryError`。 **JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。**
 
 ![]({{ "/assets/img4post/2019-09-23-java内存区域-运行时常量池.jpg" | absolute_url }})

### 直接内存
> 直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。
JDK1.4 中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel） 与缓存区（Buffer） 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。
本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。 
 
## 二、Java对象在虚拟机中创建过程（建议默写出来）
![]({{ "/assets/img4post/2019-09-23-java内存区域-java对象创建过程.png" | absolute_url }})

### 1、类加载检查
> 虚拟机遇到一条new指令时，首先将去检查这条指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否被正常加载过、解析和初始化过。如果没有，必须先执行响应的类加载过程。

### 2、内存分配
> 在类加载检查通过后，接下来虚拟机将为新生的对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从java堆中划分出来。分配方式有“指针碰撞”和“空闲列表”两种，选择哪种分配方式由java堆是否规整决定，而Java堆是否规整又是由Java垃圾收集器是否带有压缩功能决定。

- 内存分配方式
 ![]({{ "/assets/img4post/2019-09-23-java内存区域-内存分配方式.png" | absolute_url }})
 
- 内存分配并发问题
	> 在创建对象时有一个很重要的问题，就是线程安全，因为在实际的开发过程中，创建对象是很频繁的事情，对虚拟机来说，必须要保证是线程安全的。
	
  - **CAS+失败重试：**CAS是乐观锁的一种实现方式。正所谓乐观锁，每次不加锁而是假设没有锁去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用CAS配上失败重试的方式保证更新操作的原子性**
 	
  - **TLAB:** 为每一个线程预先在Eden区分配一块内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中剩余内存或TLAB内存已经用尽，再采用上述的CAS进行内存分配。

### 3、初始化零值
> 内存分配完成后，虚拟机需要将分配得到的内存都空间都初始化为0值，这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的的零值。
 

### 4、设置对象头
> 初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类对象的元数据信息、对象的hash码、对象的GC分代年龄信息。这些信息存在对象头中。另外、根据虚拟机当前的运行状态不同，如是否启用偏向锁、对象头会有不同的设置方式。

### 5、执行init方法
> 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

## 三、对象的内存布局
> 在Hotspot虚拟机中，对象在内存中的布局分为三部分：**对象头、实例数据、对齐填充。** 

- **对象头**：包括两部分信息，第一部分用于存储对象自身的自身运行时数据(hash码、GC分代年龄、锁状态标志等)；第二部分是类型指针，即对象指向他的类元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例。
- **实例数据**：实例部分是真正存储的有效信息，也是程序中所定义的各种类型的字段内容。
- **对齐填充**：这部分内容不是必然存在的，也没有什么特别的含义，仅仅起到占位作用。因为在Hotspot虚拟机的内存管理系统要求对象的起始地址必须是8字节的整数倍，换句话说，对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或2倍），因此，当对象实例部分数据没有对齐时，就需要对齐填充来补全。


 


 















  